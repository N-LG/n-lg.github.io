<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family: "Courier New", Courier, monospace;}</style><title>syscall</title></head><body><hr><a id="sommaire"></a>les fonctions système sont appelé avec les interruptions 60h à 6Fh en assembleur ou avec leurs <a href="#fonctionsC">fonctionsC</a> équivalent en C</br>si il y as plusieurs fonction disponible, le numéros de la fonction sera dans le registre al</br></br><a href="#int60h">int60h</a> termine la tache en cours</br><a href="#int61h">int61h</a> fonctions générales</br><a href="#int62h">int62h</a> force la commutation de tâche</br><a href="#int63h">int63h</a> fonctions d'interface</br><a href="#int64h">int64h</a> fonctions fichier</br><a href="#int65h">int65h</a> fonction de communication inter-tâche</br><a href="#int66h">int66h</a> fonctions port série et parallèles</br><a href="#int68h">int68h</a> fonctions périphériques usb</br></br>codes d'<a href="#erreurs">erreurs</a></br>codes de <a href="#services">services</a></br></br></br></br></br><hr><a id="int60h"></a><h1>int 60h</h1>termine la tache en cours (pas d'argument)</br></br>équivalent C: <a href="#stop()">stop()</a></br></br>                                     </br><hr><a id="int61h"></a><h1>int 61h fonctions générales</h1><a href="#int61h,0">int61h,0</a>  envoyer une commande au système</br><a href="#int61h,1">int61h,1</a>  mettre en veille la tache</br><a href="#int61h,2">int61h,2</a>  obtenir ID</br><a href="#int61h,3">int61h,3</a>  obtenir commande</br><a href="#int61h,4">int61h,4</a>  obtenir option dans commande (par n°)</br><a href="#int61h,5">int61h,5</a>  obtenir option dans commande (par lettre)</br><a href="#int61h,6">int61h,6</a>  écrire une ligne dans le journal</br><a href="#int61h,7">int61h,7</a>  modifier descriptif de la tache</br><a href="#int61h,8">int61h,8</a>  modifier taille d'un segment de la tache</br><a href="#int61h,9">int61h,9</a>  lire la date et l'heure actuelle</br><a href="#int61h,10">int61h,10</a> déclarer son type de service</br><a href="#int61h,11">int61h,11</a> rechercher un service</br><a href="#int61h,12">int61h,12</a> lire compteur temps</br><a href="#int61h,13">int61h,13</a> obtenir message système</br><a href="#int61h,14">int61h,14</a> lire le journal</br><a href="#int61h,15">int61h,15</a> copier des données dans la zone de copier/coller</br><a href="#int61h,16">int61h,16</a> lire les données dans la zone de copier/coller</br><a href="#int61h,17">int61h,17</a> effacer la zone de copier/coller</br><a href="#int61h,18">int61h,18</a> lire le dossier de travail en cours</br><a href="#int61h,19">int61h,19</a> rechercher les taches que l'on as crée</br></br><a href="#int61h,100">int61h,100</a> convertir chaine décimale asciiz en entier 32bits</br><a href="#int61h,101">int61h,101</a> convertir chaine hexadécimale en entier 32bits</br><a href="#int61h,102">int61h,102</a> convertir entier 32bits en chaine décimale asciiz</br><a href="#int61h,103">int61h,103</a> convertir entier 32bits en chaine hexadécimale asciiz</br><a href="#int61h,104">int61h,104</a> convertir entier 16bits en chaine hexadécimale asciiz</br><a href="#int61h,105">int61h,105</a> convertir entier 8bits en chaine hexadécimale asciiz</br><a href="#int61h,108">int61h,108</a> convertir chaine asciiz en adresse Ethernet </br><a href="#int61h,109">int61h,109</a> convertir chaine asciiz en adresse ipv4</br><a href="#int61h,110">int61h,110</a> convertir chaine asciiz en adresse ipv6</br><a href="#int61h,111">int61h,111</a> convertir adresse Ethernet en chaine asciiz</br><a href="#int61h,112">int61h,112</a> convertir adresse ipv4 en chaine asciiz</br><a href="#int61h,113">int61h,113</a> convertir adresse ipv6 en chaine asciiz</br><a href="#int61h,114">int61h,114</a> convertir chaine utf8Z en GUID/UUID(en cours de dévellopement)</br><a href="#int61h,115">int61h,115</a> convertir GUID/UUID en chaine utf8Z(en cours de dévellopement)</br><a href="#int61h,116">int61h,116</a> convertir données base64 en données binaires</br><a href="#int61h,117">int61h,117</a> convertir données binaires en base64 </br><a href="#int61h,118">int61h,118</a> convertir données binaires en base64url</br><a href="#int61h,119">int61h,119</a> convertire un compteur temp unix (unix timestamp) en date et heure </br><a href="#int61h,120">int61h,120</a> convertire une date et une heure en un compteur temp unix (unix timestamp)</br><a href="#int61h,150">int61h,150</a> calcul un crc16</br><a href="#int61h,151">int61h,151</a> calcul un crc32</br><a href="#int61h,152">int61h,152</a> décompresse une zone compressé par deflate</br><a href="#int61h,153">int61h,153</a> décompresse un fichier compressé par deflate</br></br></br><hr><a id="int61h,0"></a><h1>envoyer une commande au système</h1><h2>entrées:</h2>al = 0</br>ds:edx = pointeur vers la commande a envoyer sous la forme d'une chaine utf8Z</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br></br>équivalent C: <a href="#cmd()">cmd()</a> </br></br></br><hr><a id="int61h,1"></a><h1>mettre la tache en pause</h1><h2>entrées:</h2>al = 1</br>ecx = durée de la pause divisé par 2.5ms</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#delay()">delay()</a> </br></br></br></br><hr><a id="int61h,2"></a><h1>obtenir l'ID de la tâche</h1><h2>entrées:</h2>al = 2</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>bx = ID de la tache</br>équivalent C: <a href="#id_tache()">id_tache()</a> </br></br></br></br><hr><a id="int61h,3"></a><h1>lire la commande qui as appelé la tache</h1><h2>entrées:</h2>al = 3</br>ds:edx = zone de 512 octet ou sera écrit la commande</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#arg_tot()">arg_tot()</a> </br></br></br></br><hr><a id="int61h,4"></a><h1>lire un argument de la tache (par numéro)</h1><h2>entrées:</h2>al = 4ah = numéros de l'argumentds:edx = pointeur vers la zone mémoire ou copier l'argument</br>cl = taille maximum (0=256)</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#arg_num()">arg_num()</a> </br></br></br></br><hr><a id="int61h,5"></a><h1>lire un argument de la tache (par lettre)</h1><h2>entrées:</h2>al = 5</br>ah = lettre de l'argument</br>ds:edx = pointeur vers la zone mémoire ou copier l'argument sous la forme d'une chaine utf8Z</br>cl = taille maximum (0=256)</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#arg_lettre()">arg_lettre()</a> </br></br></br></br><hr><a id="int61h,6"></a><h1>ajouter du texte dans le journal systeme</h1><h2>entrées:</h2>al = 6</br>ds:edx = pointeur vers le texte a écrire dans le journal sous la forme d'une chaine utf8Z</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#printJ()">printJ()</a> </br></br></br></br><hr><a id="int61h,7"></a><h1>modifier le descripteur de la tâche</h1><h2>entrées:</h2>al = 7</br>ds:edx = pointeur vers le texte a écrire dans le descripteur de tache sous la forme d'une chaine utf8Z</br><h2>sorties:</h2>eax = <a href="#erreurs">erreurs</a> code d'erreur</br>équivalent C: <a href="#printD()">printD()</a> </br></br></br></br><hr><a id="int61h,8"></a><h1>modifier la taille d'un des segment de la tâche</h1><h2>entrées:</h2>al = 8</br>dx = sélecteur du segment a modifier</br>ecx = taille du segment souhaité</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br>équivalent C: <a href="#changeT()">changeT()</a> </br></br></br></br><hr><a id="int61h,9"></a><h1>lire la date et l'heure</h1><h2>entrées:</h2>al = 9</br><h2>sorties:</h2>bh = heure</br>bl = minute</br>si = seconde (en millième)</br>dl = jour</br>dh = mois</br>cx = année</br></br>équivalent C: <a href="#lireDH()">lireDH()</a> </br></br></br></br><hr><a id="int61h,10"></a><h1>change le code de service de la tâche</h1><h2>entrées:</h2>al = 10</br>ah = code <a href="#services">services</a></br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br>équivalent C: <a href="#changeS()">changeS()</a> </br></br></br></br><hr><a id="int61h,11"></a><h1>recherche des services</h1><h2>entrées:</h2>al = 11</br>ah = <a href="#services">services</a> code service recherché</br>ds:edx = pointeur vers la zone ou copier la table des services</br>cl = nombre de service maximum dans la table</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br>équivalent C: <a href="#rechercheS()">rechercheS()</a> </br></br></br></br><hr><a id="int61h,12"></a><h1>lire le compteur temps</h1><h2>entrées:</h2>al = 12</br><h2>sorties:</h2>eax = 32bit de poids faible du compteur temps</br>edx = 32bit de poids fort du compteur temps</br></br></br></br><hr><a id="int61h,13"></a><h1>lire  message système et message d'erreur</h1><h2>entrées:</h2>al = 13</br>ah = type de message (0 = système, 1 = erreur)</br>ds:edx = pointeur vers la zone ou copier le message sous la forme d'une chaine utf8Z</br>cl = numéros du message</br>ch = taille maximum du message</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,14"></a><h1>lire le journal système</h1><h2>entrées:</h2>al = 14</br>es:edx = pointeur vers la zone ou copier le journal sous la forme d'une chaine utf8Z</br>ecx = taille maximum du message</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,15"></a><h1>copier des données dans le presse papier</h1><h2>entrées:</h2>al = 15</br>es:edx = pointeur vers les données a copier</br>ecx = taille des données a copier</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,16"></a><h1>lire des données dans le presse papier</h1><h2>entrées:</h2>al = 16</br>es:edx = pointeur vers l'endroit ou il faut écrire le presse papier</br>ecx = taille des données a maximum que l'on peut écrire</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,17"></a><h1>effacer le contenue du presse papier</h1><h2>entrées:</h2>al = 17</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,18"></a><h1>lire l'adresse du dossier de travail</h1><h2>entrées:</h2>al = 18</br>es:edx = pointeur vers la zone de 512 octet ou copier l'adresse du dossier de travail sous la forme d'une chaine <a href="#utf8Z">utf8Z</a></br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,19"></a><h1>recherche les taches que l'on as créer</h1><h2>entrées:</h2>al = 11</br>ds:edx = pointeur vers la zone ou copier la table des id de tache</br>cl = nombre de tache maximum dans la table</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int61h,100"></a><h1>convertir une chaine de caractère représentant un nombre décimal</h1><h2>entrées:</h2>al = 100</br>ds:edx = pointeur vers la chaine a convertir</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ecx = valeur de ce nombre</br></br><hr><a id="int61h,101"></a><h1>convertir une chaine de caractère représentant un nombre hexadécimal</h1><h2>entrées:</h2>al = 101</br>ds:edx = pointeur vers la chaine a convertir</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ecx = valeur de ce nombre</br></br></br></br><hr><a id="int61h,102"></a><h1>convertir un nombre 32bits en une chaine de caractère de sa représentation décimal</h1><h2>entrées:</h2>al = 102</br>ecx = nombre</br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,103"></a><h1>convertir un nombre 32bits en une chaine de caractère de sa représentation hexadécimal</h1><h2>entrées:</h2>al = 103</br>ecx = nombre</br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,104"></a><h1>convertir un nombre 16bits en une chaine de caractère de sa représentation hexadécimal</h1><h2>entrées:</h2>al = 104</br>ecx = nombre</br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,105"></a><h1>convertir un nombre 8bits en une chaine de caractère de sa représentation hexadécimal</h1><h2>entrées:</h2>al = 105</br>ecx = nombre</br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,108"></a><h1>convertir une chaine de caractère représentant une adresse ethernet en adresse ethernet codé comme dans une trame</h1><h2>entrées:</h2>al = 108</br>ds:ecx = pointeur vers l'adresse a convertir</br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,109"></a><h1>convertir une chaine de caractère représentant une adresse ipv4 en adresse ipv4 codé comme dans une trame</h1><h2>entrées:</h2>al = 109</br>ds:ecx = pointeur vers l'adresse a convertir</br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,110"></a><h1>convertir une chaine de caractère représentant une adresse ipv6 en adresse ipv6 codé comme dans une trame</h1><h2>entrées:</h2>al = 110</br>ds:ecx = pointeur vers l'adresse a convertir</br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,111"></a><h1>convertir adresse ethernet codé comme dans une trame en une chaine de caractère représentant une adresse ethernet</h1><h2>entrées:</h2>al = 111</br>ds:ecx = pointeur vers la a zone ou sera copié le résultat</br>ds:edx = pointeur vers la chaine de caractère a convertir</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,112"></a><h1>convertir adresse ipv4 codé comme dans une trame en une chaine de caractère représentant une adresse ipv4</h1><h2>entrées:</h2>al = 112</br>ds:ecx = pointeur vers la a zone ou ser copié le résultat</br>ds:edx = pointeur vers la chaine de caractère a convertir</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,113"></a><h1>convertir adresse ipv6 codé comme dans une trame en une chaine de caractère représentant une adresse ipv6</h1><h2>entrées:</h2>al = 113</br>ds:ecx = pointeur vers la a zone ou ser copié le résultat</br>ds:edx = pointeur vers la chaine de caractère a convertir</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,116"></a><h1>convertir une chaine Base64(tout type) en binaire</h1><h2>entrées:</h2>al = 116</br>ds:esi = chaine en base64 a convertir</br>ecx = taille de la chaine</br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,117"></a><h1>convertir donnée binaire en une chaine Base64 générale</h1><h2>entrées:</h2>al = 117</br>ds:esi = données binaire a convertir</br>ecx = taille des donnée</br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int61h,118"></a><h1>convertir donnée binaire en une chaine Base64 pour Url </h1><h2>entrées:</h2>al = 118</br>ds:esi = données binaire a convertire</br>cx = taille des donnée</br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br><hr><a id="int61h,119"></a><h1>convertire un compteur temp unix (unix timestamp) en date et heure </h1><h2>entrées:</h2>al = 119</br>ecx = lsb du comteur temp</br>edx = msb du compteur temp</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>bh = heurebl = minute</br>si = seconde (en millième)</br>dl = jourdh = mois</br>cx = année</br></br></br></br><hr><a id="int61h,120"></a><h1>convertire une date et une heure en un compteur temp unix (unix timestamp)</h1><h2>entrées:</h2>al = 119</br>bh = heure</br>bl = minute</br>si = seconde (en millième)</br>dl = jour</br>dh = mois</br>cx = année</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ecx = lsb du comteur temp</br>edx = msb du compteur temp</br></br></br></br><hr><a id="int61h,150"></a><h1>calcul un CRC16</h1><h2>entrées:</h2>al = 150</br>ds:esi = début de la chaine</br>ecx = Nb d'octet de la chain</br>ebx = valeur initiale du CRC</br>dx = "polynome"</br><h2>sorties:</h2>ax = valeur du CRC</br></br></br></br><hr><a id="int61h,151"></a><h1>calcul un CRC32</h1><h2>entrées:</h2>al = 151</br>ds:esi = début de la chaine</br>ecx = Nb d'octet de la chaine</br>ebx = valeur initiale du CRC</br>edx = "polynome"</br><h2>sorties:</h2>eax = valeur du CRC</br></br></br></br><hr><a id="int61h,152"></a><h1>décompression deflate</h1><h2>entrées:</h2>al = 152</br>ds:esi = pointeur vers les données a décompresser</br>es:edi = pointeur ver la zone ou seront décompressé les données</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>esi = nombre d'octet de la partie compressé</br>edi = nombre d'octet de la partie decompressé</br></br></br></br><hr><a id="int61h,153"></a><h1>décompression de fichier deflate</h1><h2>entrées: </h2>al = 153</br>edx = adresse dans le fichier ou se trouve les données compressé</br>esi = n° du descripteur du fichier compressé</br>edi = n° du descripteur du fichier ou seront décopressé les données</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>esi = nombre d'octet de la partie compressé</br>edi = nombre d'octet de la partie decompressé</br></br></br></br></br><hr><a id="int62h"></a><h1>int 62h</h1>force la commutation de tâche (pas d'argument)</br>équivalent C: <a href="#raf()">raf()</a> </br></br><hr><a id="int63h"></a><h1>int 63h</h1><a href="#int63h,0">int63h,0</a>  création console</br><a href="#int63h,1">int63h,1</a>  suppression console</br><a href="#int63h,2">int63h,2</a>  obtenir information écran</br><a href="#int63h,3">int63h,3</a>  change la console affiché</br><a href="#int63h,5">int63h,5</a>  obtient le caractère+touche de la fifo de réception clavier</br><a href="#int63h,6">int63h,6</a>  acquisition d'une chaine de caractère validé par entrée</br><a href="#int63h,7">int63h,7</a>  demande la mise a jour complète de l'écran</br><a href="#int63h,8">int63h,8</a>  demande la mise a jour partielle de l'écran</br><a href="#int63h,10">int63h,10</a> écrire une chaine utf8Z a une position défini</br><a href="#int63h,11">int63h,11</a> écrire une chaine a la position du curseur</br><a href="#int63h,12">int63h,12</a> définir la position du curseur</br><a href="#int63h,13">int63h,13</a> système de choix par menu</br><a href="#int63h,14">int63h,14</a> barre de progression mode texte</br><a href="#int63h,21">int63h,21</a> dessine un pixel a la position x y avec une couleur prédéterminé</br><a href="#int63h,22">int63h,22</a> dessiner un carré de couleur avec une couleur prédéterminé</br><a href="#int63h,23">int63h,23</a> dessiner un segment avec une couleur prédéterminé</br><a href="#int63h,24">int63h,24</a> dessiner un disque avec une couleur prédéterminé</br><a href="#int63h,25">int63h,25</a> écrire une chaine a la position x y</br><a href="#int63h,26">int63h,26</a> écrire une chaine a la position x y suivant une largeur maximale</br><a href="#int63h,27">int63h,27</a> écrire une image a la position x y</br><a href="#int63h,50">int63h,50</a> crée une image vide</br><a href="#int63h,51">int63h,51</a> lit les caractéristiques d'un fichier image</br><a href="#int63h,52">int63h,52</a> lit l'image d'un fichier image</br><a href="#int63h,53">int63h,53</a> déplace une image avec réadaptation de la taille</br><a href="#int63h,54">int63h,54</a> déplace un fragment d'image</br><a href="#int63h,55">int63h,55</a> insère une image dans une autre</br></br></br></br><hr><a id="int63h,0"></a><h1>création console</h1><h2>entrées:</h2>al = 0ah = options</br>dx = selecteur du segment a uttiliser pour la console</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,1"></a><h1>fermeture console</h1><h2>entrées:</h2>al = 1</br><h2>sorties:</h2>aucunes sorties</br></br></br></br><hr><a id="int63h,2"></a><h1>lit les caractéristiques de l'écran</h1><h2>entrées:</h2>al = 2</br>ds:edx = pointeur ou copier la table des informations (voir ci dessous)</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,3"></a><h1>changement console affiché</h1><h2>entrées:</h2>al = 3</br>dx = id de la tâche que l'on souhaite afficher</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,5"></a><h1>lecture saisie clavier</h1><h2>entrées:</h2>al = 5</br><h2>sorties:</h2>al = code de touche ou du bouton souris (valeurs F0h à FFh)</br>ah = état des touche spéciales</br>│7│6│5│4│3│2│1│0│  </br> │ │ │ │ │ │ │ └───── Maj gauche</br> │ │ │ │ │ │ └────── Maj droit</br> │ │ │ │ │ └─────── Ctrl gauche </br> │ │ │ │ └──────── Ctrl droit</br> │ │ │ └───────── Alt</br> │ │ └────────── Alt Gr</br> └─┴─────────── innutilisé</br>ebx = 0 ou position X si souris</br>ecx = caractère associé a la touche ou position Y si souris</br></br></br></br><hr><a id="int63h,6"></a><h1>acquisition d'une chaine</h1><h2>entrées:</h2>al = 6</br>ah = couleur</br>ds:edx=adresse ou sera ecrit la chaine (avec chaine de pré remplissage obligatoire)</br>ecx = nombre d'octet max</br><h2>sorties:</h2>al = code touche qui a validé la saisie</br></br></br></br><hr><a id="int63h,7"></a><h1>demande la mise a jour complète de l'écran</h1><h2>entrées:</h2>al = 7</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,8"></a><h1>demande la mise a jour partielle de l'écran</h1><h2>entrées:</h2>al = 8</br>ebx = coordonnée X coin supérieur gauche</br>ecx = coordonnée Y coin supérieur gauche</br>esi = coordonné X coin inférieur droit</br>edi = coordonné X coin inférieur droit</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,10"></a><h1>écrire une chaine utf8Z a une position défini</h1><h2>entrées:</h2>al = 10</br>ah = couleur</br>ds:edx = pointeur vers chaine de caractère <a href="#utf8Z">utf8Z</a></br>ebx = position en X</br>ecx = position en Y</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,11"></a><h1>écrire une chaine a la position du curseur</h1><h2>entrées:</h2>al = 11</br>ah = couleur</br>ds:edx = pointeur vers chaine de caractère utf8z</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br></br><hr><a id="int63h,12"></a><h1>définir la position du curseur</h1><h2>entrées:</h2>al = 12</br>ebx = position en X</br>ecx = position en Y</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br></br><hr><a id="int63h,13"></a><h1>système de choix par menu</h1><h2>entrées:</h2>al = 13</br>bl = ligne preselectionné</br>bh = couleur de base (3bits)</br>cl = première ligne du menuch = nombre de ligne  </br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>bl = ligne selectionné</br>bh = touche qui as validé</br></br></br></br><hr><a id="int63h,14"></a><h1>barre de progression mode texte</h1><h2>entrées:</h2>al = 14</br>esi = progression</br>edi = total</br>ebx = position X de la barre</br>ecx = position Y de la barree</br>dx = taille de la barre en nombre de caractère</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int63h,21"></a><h1>dessine un pixel a la position x y avec une couleur prédéterminé</h1><h2>entrées:</h2>al = 21</br>ah = bit par pixel de la couleur</br>bx = position X</br>cx = position Y</br>edx = couleur </br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,22"></a><h1>dessiner un carré de couleur avec une couleur prédéterminé</h1><h2>entrées:</h2>al = 22</br>ah = bit par pixel de la couleur</br>bx = coordonnée X coin supérieur gauche</br>cx = coordonnée Y coin supérieur gauche</br>si = coordonné X coin inférieur droit</br>di = coordonné Y coin inférieur droit</br>edx = couleur </br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,23"></a><h1>dessiner un segment avec une couleur prédéterminé</h1><h2>entrées:</h2>al = 23</br>ah = bit par pixel de la couleur</br>bx = coordonnée X début</br>cx = coordonnée Y début</br>si = coordonné X fin</br>di = coordonné Y fin</br>edx = couleur</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,24"></a><h1>dessiner un disque avec une couleur prédéterminé</h1><h2>entrées:</h2>al = 24</br>ah = bit par pixel de la couleur</br>bx = position X</br>cx = position Y</br>edx = couleur</br>esi=rayon du disque</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,25"></a><h1>écrire une chaine a la position x y</h1><h2>entrées:</h2>al = 25</br>ah = couleur</br>bx = position X</br>cx = position Y</br>ds:edx = pointeur vers la chaine <a href="#utf8Z">utf8Z</a></br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,26"></a><h1>écrire une chaine a la position x y suivant une largeur maximale</h1><h2>entrées:</h2>al = 26</br>ah = couleur</br>bx = position X</br>cx = position Y</br>ds:edx = pointeur vers la chaine <a href="#utf8Z">utf8Z</a></br>esi = nombre de caractère max en largeur</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,27"></a><h1>écrire une image a la position x y</h1><h2>entrées:</h2>al = 27</br>bx = position X</br>cx = position Y</br>ds:edx = pointeur vers une image au format <a href="#BMS">BMS</a></br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,50"></a><h1>crée une image vide</h1><h2>entrées:</h2>al = 50</br>ah = nombre de bit par couleur</br>ebx = largeur de l'image</br>ecx = hauteur de l'image</br>edx = couleur de l'image</br>ds:edi=position de l'image</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,51"></a><h1>lit les caractéristiques d'un fichier image</h1><h2>entrées:</h2>al = 51</br>ebx = Id du fichier image</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ebx = largeur de l'image</br>ecx = hauteur de l'image</br>edx = [24MSB = taille image au format BMS 8LSB = bit par pixel]</br></br></br></br><hr><a id="int63h,52"></a><h1>lit l'image d'un fichier image</h1><h2>entrées:</h2>al = 52</br>ebx = Id du fichier image</br>es:edi = adresse ou copier l'image</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,53"></a><h1>déplace une image avec réadaptation de la taille</h1><h2>entrées:</h2>ds:esi = image d'origine</br>ds:edi = image de sortie</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,54"></a><h1>extrait un fragment d'image</h1><h2>entrées:</h2>al = 54</br>ds:esi = image d'origine</br>es:edi = image de sortie</br>ebx = position x du fragment</br>ecx = position y du fragment</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int63h,55"></a><h1>insère une image dans une autre</h1><h2>entrées:</h2>al = 55</br>ds:esi = image d'origine</br>ds:edi = image de sortie</br>ebx = position x du fragment</br>ecx = position y du fragment</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br></br></br><hr><a id="int64h"></a><h1>int 64h</h1>fonctions fichier</br><a href="#int64h,0">int64h,0</a>  ouvrir fichier</br><a href="#int64h,1">int64h,1</a>  fermer le fichier</br><a href="#int64h,2">int64h,2</a>  créer fichier</br><a href="#int64h,3">int64h,3</a>  supprimer fichier</br><a href="#int64h,4">int64h,4</a>  lit le fichier</br><a href="#int64h,5">int64h,5</a>  ecrire dans le fichier</br><a href="#int64h,6">int64h,6</a>  lit les attributs d'un fichier</br><a href="#int64h,7">int64h,7</a>  ecrire les attributs d'un fichier</br><a href="#int64h,8">int64h,8</a>  lire dans un secteur</br><a href="#int64h,9">int64h,9</a>  ecrire dans un secteur</br><a href="#int64h,10">int64h,10</a> lire les information d'un disque</br><a href="#int64h,11">int64h,11</a> définit le msb du numéros de secteur lors des fonction 8 et 9</br><a href="#int64h,12">int64h,12</a> met a jour la table des partition d'un disque</br><a href="#int64h,13">int64h,13</a> definis vitesse disque</br><a href="#int64h,14">int64h,14</a> définis le msb de l'adresse de lecture/ecriture fichier (fonction 4 et 5)</br><a href="#int64h,15">int64h,15</a> réserve espace pour fichier</br><a href="#int64h,16">int64h,16</a> lit contenue répertoire</br><a href="#int64h,17">int64h,17</a> lit disques disponible</br><a href="#int64h,18">int64h,18</a> lit nombre de secteur et taille secteur</br></br></br><hr><a id="int64h,0"></a><h1>ouvrir fichier</h1><h2>entrées:</h2>al = 0</br>ds:edx = chaine de caractère du nom du fichier a ouvrir</br>ebx = numéros de dossier qui contient</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a>bx=numéros du fichier</br>équivalent C: <a href="#open_file()">open_file()</a> </br></br></br></br><hr><a id="int64h,1"></a><h1>fermer fichier</h1><h2>entrées:</h2>al = 1</br>ebx = numéros du fichier a fermer  </br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>équivalent C: <a href="#close_file()">close_file()</a> </br></br></br></br><hr><a id="int64h,2"></a><h1>créer fichier</h1><h2>entrées:</h2>al = 2</br>ds:edx = chaine de caractère du nom du fichier a créer</br>ebx = numéros de dossier qui contiendra le fichier</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>bx = numéros du fichier</br>équivalent C: <a href="#create_file()">create_file()</a> </br></br></br></br><hr><a id="int64h,3"></a><h1>supprimer fichier</h1><h2>entrées:</h2>al = 3</br>ebx = numéros du fichier a fermer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>équivalent C: <a href="#delete_file()">delete_file()</a> </br></br></br></br><hr><a id="int64h,4"></a><h1>lit le fichier</h1><h2>entrées:</h2>al = 4</br>es:edi = zone ou copier les données</br>ebx = numéros du fichier ouvert</br>edx = offset dans le fichier</br>ecx = quantité a lire</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>équivalent C: <a href="#read_file()">read_file()</a> </br></br></br></br><hr><a id="int64h,5"></a><h1>ecrire dans le fichier</h1><h2>entrées:</h2>al = 5</br>es:esi = adresse des données a copier</br>ebx = numéros du fichier ouvert</br>edx = offset dans le fichier</br>ecx = quantité a ecrire</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>équivalent C: <a href="#write_file()">write_file()</a></br></br></br></br><hr><a id="int64h,6"></a><h1>lit les attributs d'un fichier</h1><h2>entrées:</h2>al = 6</br>ah = type d'attribut a lire(0=nom 1=taille fichier 2=attributs)</br>ebx = numéros du fichier</br>ds:edx=destination des données demandé</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int64h,7"></a><h1>ecrire les attributs d'un fichier</h1><h2>entrées:</h2>al = 7</br>ah = type d'attribut a modifier(0=nom 1=taille fichier 2=attributs)</br>ebx = numéros du fichier</br>ds:edx = données demandé</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int64h,8"></a><h1>lire dans un secteur</h1><h2>entrées:</h2>al = 8</br>ch = n° de disque</br>cl = nombre de secteur a lire</br>ebx = numéros de secteur</br>es:edi = zone de destination</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int64h,9"></a><h1>ecrire dans un secteur</h1><h2>entrées:</h2>al = 9</br>ch = n° de disque</br>cl = nombre de secteur a lire</br>ebx = numéros de secteur</br>ds:esi = donnée a écrire</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int64h,10"></a><h1>lire les information d'un disque</h1><h2>entrées:</h2>al = 10</br>ch = n° de disque</br>es:edi = zone de destination</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br><hr><a id="int64h,11"></a><h1>définit le msb du numéros de secteur lors des fonction 8 et 9</h1>(en cours de dévellopement)</br></br></br><hr><a id="int64h,12"></a><h1>met a jour la table des partition d'un disque</h1><h2>entrées:</h2>al = 12</br>ch = n° de disque</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br><hr><a id="int64h,13"></a><h1>definis vitesse disque</h1>(en cours de dévellopement)</br></br><hr><a id="int64h,14"></a><h1>définis le msb de l'adresse de lecture/ecriture fichier (fonction 4 et 5)</h1>(en cours de dévellopement)</br></br></br><hr><a id="int64h,15"></a><h1>réserve espace pour fichier</h1><h2>entrées:</h2>al = 15</br>ebx = numéros de descripteur fichier</br>ecx = taille du fichier a reserver</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int64h,16"></a><h1>lit contenue répertoire</h1><h2>entrées:</h2>al = 16</br>ds:edi = zt ou copier les données</br>ecx = taille max</br>edx = premier fichier a lire</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ebx = nombre de fichier chargé dans la zt</br></br></br></br><hr><a id="int64h,17"></a><h1>lit disques disponible</h1><h2>entrées:</h2>al = 17</br>ds:edx = pointeur ou copier le bitmap de 32 octet</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br>octet 0 à 15 partitions</br>octet 16 a 19 usb</br>octet 20 a 23 sata</br>octet 24 a 28 reservé</br>octet 29 = b0-b6 reservé b7= disquette </br>octet 30 = cdrom (ide+sata)</br>octet 31 = ata/atapi  </br></br></br></br><hr><a id="int64h,18"></a><h1>lit nombre de secteur et taille secteur</h1><h2>entrées:</h2>al = 18</br>ch = numéros de disque</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ecx = taille des secteurs</br>edx = msb nb de secteur</br>ebx = lsb nb de secteur</br></br></br></br></br></br><hr><a id="int65h"></a><h1>int 65h</h1>fonction de communication inter-tâche</br></br><a href="#int65h,0">int65h,0</a> ouverture canal</br><a href="#int65h,1">int65h,1</a> fermeture canal</br><a href="#int65h,2">int65h,2</a> tester changement descripteur</br><a href="#int65h,3">int65h,3</a> tester donnée disponible sur canaux</br><a href="#int65h,4">int65h,4</a> lire descripteur</br><a href="#int65h,5">int65h,5</a> ecrire descripteur</br><a href="#int65h,6">int65h,6</a> lire donnée sur canal</br><a href="#int65h,7">int65h,7</a> envoyer donnée sur canal</br><a href="#int65h,8">int65h,8</a> attendre changement descripteur sur canal</br><a href="#int65h,9">int65h,9</a> attendre donnée disponible sur canal</br><a href="#int65h,10">int65h,10</a> lire info sur canal</br></br></br><hr><a id="int65h,0"></a><h1>ouverture canal</h1><h2>entrées:</h2>al = 0</br>bx = ID de la tache avec qui communiquer</br>ecx = taille du descripteur</br>edx = attribut canal</br>esi = taille de la zone tampon d'envoie ou masque d'alignement mode 2</br>edi = taille de la zone tampon de reception</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ebx = adresse de la zone dans la mémoire haute</br>edx = adresse physique du descripteur</br></br></br></br><hr><a id="int65h,1"></a><h1>fermeture canal</h1><h2>entrées:</h2>al = 1</br>ebx = adresse du canal dans la mémoire haute</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int65h,2"></a><h1>tester changement descripteur</h1><h2>entrées:</h2>al = 2</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br>ebx = adresse du canal dans la mémoire haute</br></br></br></br><hr><a id="int65h,3"></a><h1>tester donnée disponible sur canaux</h1><h2>entrées:</h2>al = 3</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ebx = adresse du canal dans la mémoire haute</br></br></br></br><hr><a id="int65h,4"></a><h1>lire descripteur</h1><h2>entrées:</h2>al = 4</br>ebx = adresse du canal dans la mémoire haute</br>ecx = quantité a lire</br>esi = adresse dans la zone</br>es:edi = desitination</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int65h,5"></a><h1>ecrire descripteur</h1><h2>entrées:</h2>al = 5</br>ebx = adresse du canal dans la mémoire haute</br>ecx = quantité a lire</br>edi = adresse dans la zone</br>ds:esi = origine des données</br><h2>sorties:</h2>eax =  codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int65h,6"></a><h1>lire donnée sur canal</h1><h2>entrées:</h2>al = 6</br>ebx = adresse du canal dans la mémoire haute</br>ecx = taille des donnée maximum a lire</br>es:edi = zone ou seront écrite les données</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ecx = taille des données lue</br></br></br></br><hr><a id="int65h,7"></a><h1>envoyer donnée sur canal</h1><h2>entrées:</h2>al = 7</br>ebx = adresse du canal dans la mémoire haute</br>ecx = taille des donnée a envoyer</br>ds:esi = données a envoyer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ecx = taille des données écrite</br></br></br></br><hr><a id="int65h,8"></a><h1>attendre changement descripteur sur canal</h1><h2>entrées:</h2>al = 8</br>ebx = adresse du canal dans la mémoire haute</br>ecx = temps a attendre</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int65h,9"></a><h1>attendre donnée disponible sur canal</h1><h2>entrées:</h2>al = 9</br>ebx = adresse du canal dans la mémoire haute</br>ecx = temps a attendre</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int65h,10"></a><h1>lire info sur canal</h1><h2>entrées:</h2>al = 10</br>ebx = adresse du canal dans la mémoire haute</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>bx = ID de la tache au bout du canal</br>ecx = taille du descripteuredx = attribut canal</br>esi = taille de la zone tampon d'envoie</br>edi = taille de la zone tampon de reception</br>ebp = données en attente de lecture</br></br></br><hr><a id="int66h"></a><h1>int 66h</h1>fonctions port série et parallèles</br><a href="#int66h,0">int66h,0</a> envoyer octet</br><a href="#int66h,1">int66h,1</a> envoyer chaine</br><a href="#int66h,2">int66h,2</a> reçevoir octet</br><a href="#int66h,3">int66h,3</a> reçevoir chaine</br><a href="#int66h,4">int66h,4</a> lecture des bit de controle des ports</br><a href="#int66h,5">int66h,5</a> ecriture des bit de controle des ports</br><a href="#int66h,6">int66h,6</a> configurer port</br><a href="#int66h,7">int66h,7</a> reserver accès port</br><a href="#int66h,8">int66h,8</a> liberer accès port</br><a href="#int66h,9">int66h,9</a> changer la taille de la zt de reception</br></br></br></br><hr><a id="int66h,0"></a><h1>envoyer octet</h1><h2>entrées:</h2>al = 0</br>ah = numéros de port</br>cl = octet a envoyer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br>numéros de port</br>0 à 7 Port COM 1 à COM 8</br>8 à 15 Port LPT 1 à LPT 8</br></br></br><hr><a id="int66h,1"></a><h1>envoyer chaine</h1><h2>entrées:</h2>al = 1</br>ah = numéros de port</br>es:esi = donnée a envoyer</br>ecx = nombre d'octet a envoyer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int66h,2"></a><h1>reçevoir octet</h1><h2>entrées:</h2>al = 2</br>ah = numéros de port</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>cl = octet reçu</br></br></br></br><hr><a id="int66h,3"></a><h1>reçevoir chaine</h1><h2>entrées:</h2>al = 3</br>ah = numéros de port</br>es:edi = zone ou ecrire les données</br>ecx = nombre d'octet a reçevoir maximum</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int66h,4"></a><h1>lecture des bit de controle des ports</h1><h2>entrées:</h2>al = 4</br>ah = numéros de port</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ecx = bit d'<a href="#état du port">état du port</a></br></br></br><hr><a id="état du port"></a><h1>Bits d'état des ports série et parallèle</h1></br>Bits de controle pour port COM</br>│6 et +│5│4│3│2│1│0│ </br> │    │ │ │ │ │ │ └──── DTR</br> │    │ │ │ │ │ └───── RTS</br> │    │ │ │ │ └────── CTS</br> │    │ │ │ └─────── DSR</br> │    │ │ └──────── RI</br> │    │ └───────── DCD/RLSD</br> └────┴────────── innutilisé</br></br>Bits de controle pour port LPT</br>│6 et +│5│4│3│2│1│0│</br> │    │ │ │ │ │ │ └──── saut de page</br> │    │ │ │ │ │ └───── reset</br> │    │ │ │ │ └────── selection phériphérique</br> │    │ │ │ └─────── signal erreur </br> │    │ │ └──────── signal périphérique on line</br> │    │ └───────── signal plus de papier</br> └────┴────────── innutilisé</br></br></br></br><hr><a id="int66h,5"></a><h1>ecriture des bit de controle des ports</h1><h2>entrées:</h2>al = 5</br>ah = numéros de port</br>ecx = bit d'<a href="#état du port">état du port</a></br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int66h,6"></a><h1>configurer port com</h1><h2>entrées:</h2>al = 6</br>ah = numéros de port</br>ecx = vitesse du port (max 115200bit/s)</br>dl = attribut</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br>détail des attributs</br>│7│6│5│4│3│2│1│0│  </br> │ │ │ │ │ │ │ └──── 0 = 7 bits par caractère 1 = 8bit par caractère</br> │ │ │ │ │ │ └───── innutilisé</br> │ │ │ │ │ └────── 0 = 1 bit de stop, 1 =  2 bit de stop  </br> │ │ │ │ └─────── 0 = pas de bit de parité, 1 = présence d'un bit de parité</br> │ │ │ └──────── 0 = parité impaire(odd), 1 = parité paire(even)</br> └─┴─┴───────── innutilisé</br></br></br><hr><a id="int66h,7"></a><h1>reserver accès port</h1><h2>entrées:</h2>al = 7</br>ah = numéros de port</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int66h,8"></a><h1>liberer accès port</h1><h2>entrées:</h2>al = 8</br>ah = numéros de port</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int66h,9"></a><h1>changer la taille de la zt de reception d'un port com</h1><h2>entrées:</h2>al = 9</br>ah = numéros de porte</br>cx = taille de la zone tampon de réception</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="int68h"></a><h1>int 68h</h1><a href="#int68h,0">int68h,0</a> réservation périphérique</br><a href="#int68h,1">int68h,1</a> liberation acces périphérique</br><a href="#int68h,2">int68h,2</a> lecture descripteur</br><a href="#int68h,3">int68h,3</a> selection configuration actuelle</br><a href="#int68h,10">int68h,10</a> envoie commande brute</br><a href="#int68h,11">int68h,11</a> echange données bulk</br><a href="#int68h,12">int68h,12</a> ouverture connexion isocrone vers terminaison(en cours de dévellopement)</br><a href="#int68h,13">int68h,13</a> ouverture connexion interruption vers terminaison(en cours de dévellopement)</br><a href="#int68h,14">int68h,14</a> fermeture connexion iso ou int(en cours de dévellopement)</br><a href="#int68h,15">int68h,15</a> echange données canal isocrone ou int (en cours de dévellopement)</br></br></br><hr><a id="int68h,0"></a><h1>réservation périphérique</h1><h2>entrées:</h2>al = 0</br>bl = adresse du périphérique à reserver</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,1"></a><h1>liberation acces périphérique</h1><h2>entrées:</h2>al = 1</br>bl = adresse du périphérique à liberer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,2"></a><h1>lecture descripteur</h1><h2>entrées:</h2>al = 2</br>bl = adresse du périphérique</br>bh = terminaison   `???????????????????????????`</br>dl = index du descripteur</br>dh = type de descripteur</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,3"></a><h1>selection configuration actuelle</h1><h2>entrées:</h2>al = 3</br>`??????????????????????????????????????????`</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br></br><hr><a id="int68h,10"></a><h1>envoie commande</h1><h2>entrées:</h2>al = 10</br>bl = adresse du périphérique</br>bh = terminaison  `????????????????????????`</br>dl = index du descripteur</br>dh = type de descripteur</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,11"></a><h1>echange donnée bulk</h1><h2>entrées:</h2>al = 11</br>bl = adresse du périphérique</br>bh = terminaison + sens</br>dl = index du descripteur</br>dh = type de descripteur</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,12"></a><h1>ouverture canal isocrone</h1><h2>entrées:</h2>al = 12</br>bl = adresse du périphérique</br>bh = terminaison</br>ecx = taille d'une trame</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ebx = adresse du canal si aucunes erreurs</br></br><hr><a id="int68h,13"></a><h1>ouverture canal interruption</h1><h2>entrées:</h2>al = 13</br>bl = adresse du périphérique à liberer</br>bh = terminaison</br>dl = periodicité</br>ecx = taille d'une trame</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br>ebx = adresse du canal si aucunes erreurs</br></br><hr><a id="int68h,14"></a><h1>fermeture canal isocrone ou interruption</h1><h2>entrées:</h2>al = 14</br>ebx = adresse du canal a fermer</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br><hr><a id="int68h,15"></a><h1>echange de donné sur canal isocrone ou interruption</h1><h2>entrées:</h2>al = 15</br>ebx = adresse du canal </br>ecx =taille des données a transferer</br>ds:edx =adresse de la zt des données</br><h2>sorties:</h2>eax = codes d'<a href="#erreurs">erreurs</a></br></br></br></br><hr><a id="erreurs"></a><h1>codes d'erreurs</h1> 0 fonction exécute sans erreur</br> 1 paramètre incorrecte</br> 2 erreur de lecture</br> 3 lecteur/disque/fichier non trouvé</br> 4 erreur du système de fichier</br> 5 erreur d'écriture</br> 6 pas de réponse disque</br> 7 disque occupé</br> 8 fichier déjà ouvert</br> 9 interdiction de lecture</br>10 interdiction d'ouverture</br>11 plus assez de mémoire</br>12 le fichier ouvert est un dossier</br>13 erreur d'origine inconnue (normalement jamais utilisé, sauf erreur)</br>14 nombre de couleur non reconnue</br>15 écran absent</br>16 zone tampon vide</br>17 zone tampon pleine</br>18 contrôleur ne répond pas</br>19 contrôleur absent</br>20 dossier non vide (dans le cas d'une suppression)</br>21 dossier non vide (dans le cas d'une suppression)</br>22 caractère interdit dans le nom de fichier</br>23 création de fichier impossible</br></br></br><hr><a id="services"></a><h1>codes de services</h1>0 aucun service</br>1 écran</br>2 camera</br>3 imprimante</br>4 scanner</br>5 son</br>6 réseau Ethernet</br>7 reseau wifi</br>8 service dns</br>9</br>10 aucun service</br>11 à 63 réservé pour les standard</br>64 à 255 utilisable</br></br></br></br><hr><a id="fonctionsC"></a><h1>fonction en C</h1><a href="#stop()">stop()</a></br><a href="#cmd()">cmd()</a></br><a href="#delay()">delay()</a></br><a href="#id_tache()">id_tache()</a></br><a href="#arg_tot()">arg_tot()</a></br><a href="#arg_num()">arg_num()</a></br><a href="#arg_lettre()">arg_lettre()</a></br><a href="#printJ()">printJ()</a></br><a href="#printD()">printD()</a></br><a href="#changeT()">changeT()</a></br><a href="#lireDH()">lireDH()</a></br><a href="#changeS()">changeS()</a></br><a href="#rechercheS()">rechercheS()</a></br><a href="#compteur()">compteur()</a></br><a href="#message_systeme()">message_systeme()</a></br><a href="#message_erreur()">message_erreur()</a></br><a href="#lire_journal()">lire_journal()</a></br><a href="#ecrire_pp()">ecrire_pp()</a></br><a href="#lire_pp()">lire_pp()</a></br><a href="#effacer_pp()">effacer_pp()</a></br><a href="#lire_dossier_travail()">lire_dossier_travail()</a></br><a href="#sous_taches()">sous_taches()</a></br><a href="#deci()">deci()</a></br><a href="#hexa()">hexa()</a></br><a href="#long2deci()">long2deci()</a></br><a href="#long2hexa()">long2hexa()</a></br><a href="#etherS2B()">etherS2B()</a></br><a href="#ipv4S2B()">ipv4S2B()</a></br><a href="#ipv6S2B()">ipv6S2B()</a></br><a href="#etherB2S()">etherB2S()</a></br><a href="#ipv4B2S()">ipv4B2S()</a></br><a href="#ipv6B2S()">ipv6B2S()</a></br><a href="#base64binaire()">base64binaire()</a></br><a href="#raf()">raf()</a></br><a href="#open_file()">open_file()</a></br><a href="#close_file()">close_file()</a></br><a href="#create_file()">create_file()</a></br><a href="#delete_file()">delete_file()</a></br><a href="#read_file()">read_file()</a></br><a href="#write_file()">write_file()</a></br><a href="#taille_file()">taille_file()</a></br><a href="#error_file()">error_file()</a></br></br></br></br></br></br><hr><a id="stop()"></a><h1>void stop()</h1>termine la tache en cours</br></br></br><hr><a id="cmd()"></a><h1>void cmd(char* ¨commande¨)</h1>Envoie une commande au systeme</br>¨commande¨ = commande a envoyer au systeme</br></br></br><hr><a id="delay()"></a><h1>void delay(unsigned long ¨temps¨)</h1>attend</br>¨temps¨ = temps à attendre en milliseconde</br></br></br><hr><a id="id_tache()"></a><h1>unsigned int id_tache()</h1>Renvoie l'id de la tache</br></br></br></br><hr><a id="arg_tot()"></a><h1>long arg_tot(char *¨string¨)</h1>lit la commande de la tache</br>¨string¨ = zone de 512 octet ou sera recopiéla commande</br></br></br><hr><a id="arg_num()"></a><h1>long arg_num(char ¨numero¨,char *string)</h1>lit un argument par son numéros</br>¨numero¨ = numéro de l'argument a lire</br>¨string¨ = zone de 256 octet ou sera recopié l'argument</br></br></br><hr><a id="arg_lettre()"></a><h1>long arg_lettre(char ¨lettre¨,char *¨string¨)</h1>lit un argument par sa lettre</br>¨lettre¨ = numéro de l'argument a lire</br>¨string¨ = zone de 256 octet ou sera recopié l'argument</br></br></br></br><hr><a id="printJ()"></a><h1>void printJ(char *¨string¨)</h1>ecrit dans le journal systeme</br>¨string¨ = chaine a ecrire dans le journal</br></br></br><hr><a id="printD()"></a><h1>void printD(char *¨string¨)</h1>change le descriptif de tache</br>¨string¨ = chaine a ecrire dans le descripteur de tache</br></br></br><hr><a id="changeT()"></a><h1>long changeT(long ¨taille¨)</h1>change la taille mémoire occupé par la tache</br>¨taille¨ = taille souhaité</br></br></br><hr><a id="lireDH()"></a><h1>struct dateheure lireDH()</h1>lire la date et l'heure</br>renvoie une structure d type dateheure</br></br></br><hr><a id="changeS()"></a><h1>void changeS(unsigned char ¨service¨)</h1>change le service de la tache</br>¨service¨ = <a href="#services">services</a> code service fournis par l'application</br></br></br><hr><a id="rechercheS()"></a><h1>unsigned long rechercheS(unsigned char ¨service¨,unsigned int *table,unsigned char taille)</h1>recherche une tache par son service</br>¨service¨ = <a href="#services">services</a> code service recherché</br>¨table¨ = table d'int ou seront écrit la liste des id des tache </br>¨taille¨ = nombre d'entrée maximum de la table</br></br></br><hr><a id="compteur()"></a><h1>long compteur()</h1>lit le compteur temps</br>¨¨ =</br></br></br><hr><a id="message_systeme()"></a><h1>void message_systeme(int ¨num¨,char* ¨chaine¨)</h1>charge un message systeme</br>¨num¨ = numéros du message a charger</br>¨chaine¨ = zone de 256 octet ou seront copié le message systeme</br></br></br><hr><a id="message_erreur()"></a><h1>void message_erreur(int ¨num¨,char* ¨chaine¨)</h1>charge un message d'erreur</br>¨num¨ =   codes d'<a href="#erreurs">erreurs</a></br>¨chaine¨ = zone de 256 octet ou seront copié le message d'erreur</br></br></br><hr><a id="lire_journal()"></a><h1>void lire_journal(char* ¨chaine¨,long ¨taille¨)</h1>lit le journal systeme</br>¨chaine¨ = endroit ou copier le journal systeme</br>¨taille¨ = nombre d'octet maximum du journal a lire</br></br></br><hr><a id="ecrire_pp()"></a><h1>void ecrire_pp(char* ¨chaine¨,long ¨taille¨)</h1>ecrire dans le presse papier</br>¨¨ =</br></br></br><hr><a id="lire_pp()"></a><h1>void lire_pp(char* chaine,long taille)</h1>lit dans le presse papier</br>¨¨ =</br></br></br><hr><a id="effacer_pp()"></a><h1>void effacer_pp()</h1>efface le presse papier</br></br></br><hr><a id="lire_dossier_travail()"></a><h1>void lire_dossier_travail(char* ¨chaine¨)</h1>lit le dossier de travail</br>¨chaine¨ = espace de 512 octet ou sera copié le dosier de travail</br></br></br><hr><a id="sous_taches()"></a><h1>void sous_taches(int* ¨table¨,char ¨nb¨)</h1>liste les taches que l'on as créer</br>¨table¨ = table ou seront recopié la liste de taches</br>¨nb¨ = nombre maximum d'element de cette liste</br></br></br><hr><a id="deci()"></a><h1>long deci(char *¨chaine¨)</h1>convertit chaine décimal en nombre</br>¨chaine¨ = chaine a convertir</br></br></br><hr><a id="hexa(hexa()"></a><h1>long hexa(char *¨chaine¨)</h1>convertit chaine héxadécimal en nombre</br>¨chaine¨ = chaine a convertir</br></br></br><hr><a id="long2deci()"></a><h1>void long2deci(long ¨nombre¨,char *¨chaine¨)</h1>convertit un nombre en chaine décimal</br>¨nombre¨ = nombre a convertir</br>¨chaine¨ = chaine de 16 octets ou ecrire la conversion</br></br></br><hr><a id="long2hexa()"></a><h1>void long2hexa(long ¨nombre¨,char *¨chaine¨)</h1>convertit un nombre en chaine héxadécimal</br>¨nombre¨ = nombre a convertir</br>¨chaine¨ = chaine de 16 octets ou ecrire la conversion</br></br></br><hr><a id="etherS2B()"></a><h1>void etherS2B(char *¨entrée¨,char *¨sortie¨)</h1>convertit une adresse ethernet sous forme de chaine en forma binaire</br>¨entrée¨ = adresse en format chaine</br>¨sortie¨ = adresse en format binaire</br></br></br></br><hr><a id="ipv4S2B()"></a><h1>void ipv4S2B(char *¨entree¨,char *¨sortie¨)</h1>convertit une adresse ip V4 sous forme de chaine en forma binaire</br>¨entrée¨ = adresse en format chaine</br>¨sortie¨ = adresse en format binaire</br></br></br><hr><a id="ipv6S2B()"></a><h1>ipv6S2B(char *¨entree¨,char *¨sortie¨)</h1>convertit une adresse ip V6 sous forme de chaine en forma binaire</br>¨entrée¨ = adresse en format chaine</br>¨sortie¨ = adresse en format binaire</br></br></br><hr><a id="etherB2S()"></a><h1>void etherB2S(char *¨entree¨,char *¨sortie¨)</h1>convertit une adresse ethernet sous forme binaire en chaine</br>¨entrée¨ = adresse en format binaire</br>¨sortie¨ = adresse en format chaine</br></br></br></br><hr><a id="ipv4B2S()"></a><h1>void ipv4B2S(char *¨entree¨,char *¨sortie¨)</h1>convertit une adresse ip v4 sous forme binaire en chaine</br>¨entrée¨ = adresse en format binaire</br>¨sortie¨ = adresse en format chaine</br></br></br></br><hr><a id="ipv6B2S()"></a><h1>void ipv6B2S(char *¨entree¨,char *¨sortie¨)</h1>convertit une adresse ip v6 sous forme binaire en chaine</br>¨entrée¨ = adresse en format binaire</br>¨sortie¨ = adresse en format chaine</br></br></br><hr><a id="base64binaire()"></a><h1>base64binaire(char *¨entree¨,char *¨sortie¨, long ¨taille¨)</h1>convertir une chaine codé en base64 en donnée binaire</br>¨¨ =</br></br></br><hr><a id="raf()"></a><h1>void raf()</h1>passe a la tache suivante</br></br></br><hr><a id="open_file()"></a><h1>long open_file(char* ¨nom¨)</h1>ouvre un fichier, renvoie l'id du fichier ouvert ou -1 si cela as échoué</br>¨nom¨ = nom du fichier</br></br></br><hr><a id="close_file()"></a><h1>long close_file(long ¨id¨)</h1>ferme un fichier, renvoie le <a href="#erreurs">erreurs</a> codes d'erreur de l'opération</br>¨id¨ = id du fichier a fermer</br></br></br><hr><a id="create_file()"></a><h1>long create_file(long ¨nom¨)</h1>crée un fichier, renvoie l'id du fichier ouvert ou -1 si cela as échoué</br>¨nom¨ = nom du fichier</br></br></br><hr><a id="delete_file()"></a><h1>long delete_file(long ¨id¨)</h1>supprime un fichier, renvoie le <a href="#erreurs">erreurs</a> codes d'erreur de l'opération</br>¨id¨ = id du fichier a supprimer</br></br></br><hr><a id="read_file()"></a><h1>long read_file(long ¨id¨,long ¨offset¨,long ¨count¨,char* ¨data¨)</h1>lit dans un fichier, renvoie le <a href="#erreurs">erreurs</a> codes d'erreur de l'opération</br>¨id¨ = id du fichier a supprimer</br>¨offset¨ = adresse dans le fichier</br>¨count¨ = nombre d'octet</br>¨data¨ = ou seront écrit les donnée lut</br></br></br><hr><a id="write_file()"></a><h1>long write_file(long ¨id¨,long ¨offset¨,long ¨count¨,char* ¨data¨)</h1>ecrit dans un fichier, renvoie le  <a href="#erreurs">erreurs</a> codes d'erreur de l'opération</br>¨id¨ = id du fichier a supprimer</br>¨offset¨ = adresse dans le fichier</br>¨count¨ = nombre d'octet</br>¨data¨ = donnée a ecrire</br></br></br></br><hr><a id="taille_file()"></a><h1>long taille_file(long ¨id¨)</h1>lit la taille d'un fichier, renvoie la taille du fichier ouvert ou -1 si cela as échoué</br>¨id¨ = id du fichier a supprimer</br></br></br><hr><a id="error_file()"></a><h1>long error_file()</h1>donne le code de la dernière <a href="#erreurs">erreurs</a> erreur lorsque les fonctions renvoie -1</br></br></br><hr><a id="utf8z"></a><a id="utf8"></a><a id="ascii"></a><h1>utf8z désigne uen chaine de caractère codé en utf8 et terminé par le caractère NULL (octet valant zéro</h1></br><hr><a id="BMS"></a><h1>BMS: BitMap Simple</h1>BMS est l'objet image standard uttilisé par les fonctions graphique de Seac</br></br>             taille   contenue</br>objimage_bpp 1 octet  nombre de bit par pixel</br>objimage_att 1 octet  attributs de l'image</br>objimage_x   2 octets largeur de l'imabe en pixel</br>objimage_y   2 octets hauteur de l'imabe en pixel</br>objimage_opl 4 octets nombre d'octet par ligne</br>objimage_ctp 4 octets couleur de transparence</br>objimage_dat variable donnée de chaque pixel de gauche à droite et de haut en bas</br></br></br></br></br></br>objimage_dat variable donnée de chaque pixel de gauche à droite et de haut en bas</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></body></html>